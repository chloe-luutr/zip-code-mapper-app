# -*- coding: utf-8 -*-
"""Streamlit Zip Code Mapper App (with Uncovered ZIPs & K-12 Schools)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AdIPrCkpD1MWSsvs7ox2n_7E_F1faATd
"""

import streamlit as st
import pandas as pd
import numpy as np
import geopandas as gpd
import contextily as ctx
import matplotlib.pyplot as plt
from matplotlib.patches import Wedge
import math
import pyproj
from shapely.geometry import Point, MultiPolygon
from shapely.ops import transform, unary_union
import matplotlib.patches as mpatches
import matplotlib.lines as mlines
import io # Required for reading uploaded files

# Page Configuration (set this at the beginning)
st.set_page_config(layout="wide")

st.title("Interactive ZIP Code, School Roles & K-12 School Mapper")
st.markdown("""
Upload your CSV files to:
- Visualize school locations with open roles (pie charts) and their 5/10-mile coverage.
- Identify ZIP codes **not covered** by the 10-mile radius of open roles (highlighted as 'Recommended').
- Display K-12 school locations (optional upload).
- See ZIP codes targeted for advertisements.
""")

###############################################################################
# HELPER FUNCTIONS (Adapted from your original script)
###############################################################################

def load_us_zip_codes(uploaded_file_object) -> gpd.GeoDataFrame:
    """Loads US ZIP code data from an uploaded CSV file object."""
    if uploaded_file_object is None:
        return gpd.GeoDataFrame()
    try:
        df = pd.read_csv(uploaded_file_object, dtype={'zip': str}) # Read zip as string
        df.columns = df.columns.str.strip().str.lower()
        if 'longitude' not in df.columns or 'latitude' not in df.columns:
            st.error("US ZIP Codes CSV must contain 'longitude' and 'latitude' columns.")
            return gpd.GeoDataFrame()
        df['zip'] = df['zip'].str.zfill(5)
        gdf = gpd.GeoDataFrame(
            df,
            geometry=gpd.points_from_xy(df.longitude, df.latitude),
            crs="EPSG:4326"
        )
        return gdf
    except Exception as e:
        st.error(f"Error loading US ZIP Codes: {e}")
        return gpd.GeoDataFrame()

def load_zips_to_sort(uploaded_file_object) -> pd.DataFrame:
    """Loads ZIP codes to sort (Ad ZIPs) from an uploaded CSV file object."""
    if uploaded_file_object is None:
        return pd.DataFrame(columns=['zip'])
    try:
        try:
            df = pd.read_csv(uploaded_file_object, dtype={'zip': str}) # Read zip as string
        except pd.errors.ParserError:
            uploaded_file_object.seek(0)
            df_header_as_data = pd.read_csv(uploaded_file_object, header=None, nrows=1, dtype=str)
            if all(str(col).isdigit() and len(str(col)) == 5 for col in df_header_as_data.iloc[0]):
                 df = pd.DataFrame(df_header_as_data.iloc[0].values, columns=['zip'])
            else:
                uploaded_file_object.seek(0)
                df = pd.read_csv(uploaded_file_object, dtype={'zip': str})

        df.columns = df.columns.str.strip().str.lower()
        if 'zip' not in df.columns and df.shape[1] > 0:
            if df.iloc[:, 0].astype(str).str.match(r'^\d{5}$').all():
                 df = df.rename(columns={df.columns[0]: 'zip'})
            else:
                st.error("Zips to Sort CSV must contain a 'zip' column or have 5-digit ZIPs in the first column if header is numeric.")
                return pd.DataFrame(columns=['zip'])
        elif 'zip' not in df.columns:
             st.error("Could not find a 'zip' column in Zips to Sort CSV.")
             return pd.DataFrame(columns=['zip'])

        df['zip'] = df['zip'].astype(str).str.zfill(5)
        return df[['zip']].drop_duplicates()
    except Exception as e:
        st.error(f"Error loading Zips to Sort: {e}")
        return pd.DataFrame(columns=['zip'])

def load_school_requests(uploaded_file_object) -> pd.DataFrame:
    """Loads school requests/open roles from an uploaded CSV file object."""
    if uploaded_file_object is None:
        return pd.DataFrame()
    try:
        df = pd.read_csv(uploaded_file_object, dtype={'zip': str}) # Read zip as string
        df.columns = df.columns.str.strip().str.lower()
        if 'zip' not in df.columns:
            st.error("School Requests CSV must contain a 'zip' column.")
            return pd.DataFrame()
        df['zip'] = df['zip'].str.zfill(5)
        return df
    except Exception as e:
        st.error(f"Error loading School Requests: {e}")
        return pd.DataFrame()

def load_k12_schools(uploaded_file_object) -> gpd.GeoDataFrame:
    """Loads K-12 school locations from an uploaded CSV file object."""
    if uploaded_file_object is None:
        return gpd.GeoDataFrame() # Return empty if no file, it's optional
    try:
        df = pd.read_csv(uploaded_file_object)
        df.columns = df.columns.str.strip().str.lower()
        if 'latitude' not in df.columns or 'longitude' not in df.columns:
            st.error("K-12 Schools CSV must contain 'latitude' and 'longitude' columns.")
            return gpd.GeoDataFrame()
        # Add a 'name' column if it doesn't exist for potential tooltips later
        if 'name' not in df.columns:
            df['name'] = 'K-12 School'
        gdf = gpd.GeoDataFrame(
            df,
            geometry=gpd.points_from_xy(df.longitude, df.latitude),
            crs="EPSG:4326"
        )
        return gdf
    except Exception as e:
        st.error(f"Error loading K-12 Schools: {e}")
        return gpd.GeoDataFrame()


def geodesic_buffer(lon, lat, miles):
    """Creates a geodesic buffer around a point."""
    radius_m = miles * 1609.34
    wgs84 = pyproj.CRS("EPSG:4326")
    aeqd_proj_str = f"+proj=aeqd +lat_0={lat} +lon_0={lon} +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs"
    try:
        aeqd_proj = pyproj.CRS.from_proj4(aeqd_proj_str)
    except pyproj.exceptions.CRSError:
        st.warning(f"Could not create AEQD projection for {lat}, {lon}. Buffer might be inaccurate for this point.")
        return Point(lon, lat).buffer(radius_m / 111000) # Rough degree buffer

    project_fwd  = pyproj.Transformer.from_crs(wgs84, aeqd_proj,  always_xy=True).transform
    project_back = pyproj.Transformer.from_crs(aeqd_proj, wgs84,  always_xy=True).transform
    center = Point(lon, lat)
    center_aeqd = transform(project_fwd, center)
    buffer_aeqd = center_aeqd.buffer(radius_m)
    buffer_wgs84= transform(project_back, buffer_aeqd)
    return buffer_wgs84

def create_geodesic_buffers_for_schools(gdf_schools, radii=(5,10)):
    """Adds buffer columns to the schools GeoDataFrame."""
    if gdf_schools.empty or 'geometry' not in gdf_schools.columns:
        return gdf_schools
    for r in radii:
        col_name = f"buffer_{r}"
        poly_list = []
        for _, row in gdf_schools.iterrows():
            geom = row.geometry
            if geom is None or geom.is_empty or not isinstance(geom, Point):
                poly_list.append(None)
                continue
            lon, lat = geom.x, geom.y
            try:
                poly = geodesic_buffer(lon, lat, r)
                poly_list.append(poly)
            except Exception as e:
                st.warning(f"Buffer creation error for school ZIP {row.get('zip', 'N/A')}: {e}")
                poly_list.append(None)
        gdf_schools[col_name] = gpd.GeoSeries(poly_list, crs="EPSG:4326") # Ensure GeoSeries has CRS
    return gdf_schools

def plot_pie_chart(ax, x_center, y_center, counts_dict, radius):
    """Plots a pie chart on the given Matplotlib axes."""
    total = sum(counts_dict.values())
    if total <= 0: return
    items = sorted(counts_dict.items())
    values = [v for _, v in items]
    frac = [v / total for v in values]
    angles = np.cumsum([0] + [f * 360 for f in frac])
    colors = plt.cm.get_cmap('tab20', len(items)).colors
    for i in range(len(values)):
        wedge = Wedge(center=(x_center, y_center), r=radius, theta1=angles[i], theta2=angles[i+1],
                      facecolor=colors[i % len(colors)], edgecolor='white', linewidth=0.5, alpha=0.8, zorder=10) # ensure pies on top
        ax.add_patch(wedge)

###############################################################################
# MAIN PLOT FUNCTION (Adapted for Streamlit)
###############################################################################
def generate_map_plot(gdf_us, df_ads, df_schools, gdf_k12_schools=None):
    """Generates and returns the Matplotlib figure object."""
    if gdf_us.empty:
        st.error("US ZIP Code reference data is missing or empty. Cannot generate map.")
        fig, ax = plt.subplots()
        ax.text(0.5, 0.5, "US ZIP Data missing.", ha='center', va='center')
        return fig
    if df_ads.empty and df_schools.empty:
        st.warning("Both Ad ZIPs and School Role ZIPs data are empty. Map will be based on US ZIPs only if K-12 schools are provided.")
        # Allow map generation if K-12 schools are present, otherwise show warning.
        if gdf_k12_schools is None or gdf_k12_schools.empty:
            fig, ax = plt.subplots()
            ax.text(0.5, 0.5, "Ad and School Role Data missing.", ha='center', va='center')
            return fig


    # --- Data Preparation ---
    relevant_zips_ads = set(df_ads['zip'].astype(str).str.zfill(5).unique()) if not df_ads.empty else set()
    relevant_zips_schools = set(df_schools['zip'].astype(str).str.zfill(5).unique()) if not df_schools.empty else set()

    # For gdf_filtered, we want all zips that are either ad targets or school locations for initial context.
    # If K-12 schools are provided, we might want to expand gdf_filtered later or handle their bounds separately.
    context_zips = relevant_zips_ads | relevant_zips_schools
    if not context_zips and gdf_k12_schools is not None and not gdf_k12_schools.empty:
        # If no ad/school role zips, but K12 schools exist, we need some context.
        # This part could be improved by finding zips near K12 schools. For now, it might result in a very broad map.
        st.info("No Ad or School Role ZIPs. Map extent will be based on K-12 schools if provided, or a default US view.")
        # A better approach here would be to find zips within a certain distance of K12 schools.
        # For simplicity now, if us_zip_codes is huge, this might be slow. Consider sampling or regional filter.
        gdf_filtered = gdf_us.copy() # This could be very large.
    elif not context_zips:
        st.error("No Ad ZIPs, School Role ZIPs, or K-12 School data to display.")
        fig, ax = plt.subplots()
        ax.text(0.5, 0.5, "No data to display.", ha='center', va='center')
        return fig
    else:
         gdf_filtered = gdf_us[gdf_us['zip'].astype(str).str.zfill(5).isin(context_zips)].copy()


    if gdf_filtered.empty and (gdf_k12_schools is None or gdf_k12_schools.empty):
        st.warning("No matching ZIP codes found in the US ZIP Code reference for Ad/School ZIPs, and no K-12 schools provided.")
        fig, ax = plt.subplots()
        ax.text(0.5, 0.5, "No relevant ZIPs in master list.", ha='center', va='center')
        return fig

    gdf_ads_merged = pd.merge(df_ads, gdf_filtered[['zip','geometry']], on='zip', how='left') if not df_ads.empty else gpd.GeoDataFrame(columns=['zip', 'geometry'])
    gdf_schools_merged = pd.merge(df_schools, gdf_filtered[['zip','geometry']], on='zip', how='left') if not df_schools.empty else gpd.GeoDataFrame(columns=['zip', 'geometry'])

    gdf_ads_merged.dropna(subset=['geometry'], inplace=True)
    gdf_schools_merged.dropna(subset=['geometry'], inplace=True)

    gdf_ads_geo = gpd.GeoDataFrame(gdf_ads_merged, geometry='geometry', crs="EPSG:4326") if not gdf_ads_merged.empty else gpd.GeoDataFrame(crs="EPSG:4326")
    gdf_schools_geo = gpd.GeoDataFrame(gdf_schools_merged, geometry='geometry', crs="EPSG:4326") if not gdf_schools_merged.empty else gpd.GeoDataFrame(crs="EPSG:4326")

    excluded_cols_for_roles = ['zip', 'geometry', 'latitude', 'longitude', 'city', 'state_id', 'state_name', 'county_name', 'timezone']
    teacher_cols = []
    if not gdf_schools_geo.empty:
        teacher_cols = [c for c in gdf_schools_geo.columns if c not in excluded_cols_for_roles and pd.api.types.is_numeric_dtype(gdf_schools_geo[c])]
        if not teacher_cols: st.warning("No numeric role columns found in School Requests data for pie charts.")
        gdf_schools_geo = create_geodesic_buffers_for_schools(gdf_schools_geo, radii=(5,10))

    # --- Projections ---
    gdf_ads_3857      = gdf_ads_geo.to_crs(epsg=3857) if not gdf_ads_geo.empty else gpd.GeoDataFrame(crs="EPSG:3857")
    gdf_schools_3857  = gdf_schools_geo.to_crs(epsg=3857) if not gdf_schools_geo.empty else gpd.GeoDataFrame(crs="EPSG:3857")
    gdf_filtered_3857 = gdf_filtered.to_crs(epsg=3857) if not gdf_filtered.empty else gpd.GeoDataFrame(crs="EPSG:3857")
    gdf_k12_3857      = gdf_k12_schools.to_crs(epsg=3857) if gdf_k12_schools is not None and not gdf_k12_schools.empty else gpd.GeoDataFrame(crs="EPSG:3857")

    if 'buffer_5' in gdf_schools_geo.columns: gdf_schools_3857['buffer_5_3857']  = gpd.GeoSeries(gdf_schools_geo['buffer_5'], crs="EPSG:4326").to_crs(epsg=3857)
    if 'buffer_10' in gdf_schools_geo.columns: gdf_schools_3857['buffer_10_3857'] = gpd.GeoSeries(gdf_schools_geo['buffer_10'], crs="EPSG:4326").to_crs(epsg=3857)

    # --- Determine Uncovered ZIPs ---
    uncovered_zips_geoms = []
    all_school_buffers_union = None
    if 'buffer_10_3857' in gdf_schools_3857.columns and not gdf_schools_3857[gdf_schools_3857['buffer_10_3857'].notna()].empty:
        # Filter out None geometries before unary_union
        valid_buffers = gdf_schools_3857['buffer_10_3857'].dropna()
        if not valid_buffers.empty:
            all_school_buffers_union = unary_union(valid_buffers.tolist())


    # --- Plotting ---
    fig, ax = plt.subplots(figsize=(16,13))

    # Determine combined bounds for map extent
    all_geoms_for_bounds = []
    if not gdf_filtered_3857.empty: all_geoms_for_bounds.append(gdf_filtered_3857)
    if not gdf_schools_3857.empty: all_geoms_for_bounds.append(gdf_schools_3857)
    if not gdf_ads_3857.empty: all_geoms_for_bounds.append(gdf_ads_3857)
    if not gdf_k12_3857.empty: all_geoms_for_bounds.append(gdf_k12_3857)

    if not all_geoms_for_bounds:
        minx, miny, maxx, maxy = -13000000, 2500000, -7000000, 6500000 # Default US
    else:
        combined_gdf_for_bounds = pd.concat(all_geoms_for_bounds)
        if combined_gdf_for_bounds.empty or combined_gdf_for_bounds.total_bounds is None:
             minx, miny, maxx, maxy = -13000000, 2500000, -7000000, 6500000 # Default US
        else:
            bounds = combined_gdf_for_bounds.total_bounds
            if any(np.isnan(bounds)) or any(np.isinf(bounds)):
                minx, miny, maxx, maxy = -13000000, 2500000, -7000000, 6500000 # Default US
            else:
                minx, miny, maxx, maxy = bounds

    w = maxx - minx if maxx > minx else 1000000
    h = maxy - miny if maxy > miny else 1000000
    pad_x, pad_y = 0.1 * w, 0.1 * h

    min_jobs, max_jobs = float('inf'), 0
    if teacher_cols and not gdf_schools_geo.empty:
        for _, row in gdf_schools_geo.iterrows():
            total = sum(row.get(tc, 0) for tc in teacher_cols if pd.notna(row.get(tc, 0)))
            if total > max_jobs: max_jobs = total
            if total < min_jobs and total > 0: min_jobs = total
    if min_jobs == float('inf'): min_jobs = 0
    if max_jobs == 0: max_jobs = 1

    BIGGEST_PIE_RADIUS = 5000.0
    get_pie_radius = lambda total_jobs: BIGGEST_PIE_RADIUS * math.sqrt(max(0, total_jobs) / max_jobs) if max_jobs > 0 else 0

    # 1) Background zips & Uncovered/Recommended ZIPs
    zip_serial_map = {str(zip_code).zfill(5): i+1 for i, zip_code in enumerate(df_ads['zip'])} if not df_ads.empty else {}

    # Plot all filtered zips first, then overlay uncovered ones if any
    if not gdf_filtered_3857.empty:
        gdf_filtered_3857.plot(ax=ax, marker='o', color='lightgray', alpha=0.3, markersize=8, zorder=1, label='Contextual ZIPs (Demand/Ad Areas)')
        for _, row in gdf_filtered_3857.iterrows():
            geom = row.geometry
            zip_code_str = str(row['zip']).zfill(5)
            if geom is None or geom.is_empty: continue

            is_uncovered = False
            if all_school_buffers_union and isinstance(all_school_buffers_union, (MultiPolygon, Point)) and not all_school_buffers_union.is_empty:
                if not geom.within(all_school_buffers_union):
                    is_uncovered = True
            elif not all_school_buffers_union : # If no school buffers, all are "uncovered" by definition of school demand
                is_uncovered = True

            if is_uncovered:
                ax.plot(geom.x, geom.y, 'o', color='gold', markersize=10, alpha=0.8, zorder=2, markeredgecolor='black') # Recommended/Uncovered
                uncovered_zips_geoms.append(geom)

            serial = zip_serial_map.get(zip_code_str)
            if serial is not None: # Serial numbers only for Ad ZIPs
                ax.text(geom.x, geom.y, str(serial), color='black', fontsize=7, ha='center', va='center', zorder=5)

    # 2) Ad zips (plot again on top if they are also background, or just plot them distinctly)
    if not gdf_ads_3857.empty:
        gdf_ads_3857.plot(ax=ax, marker='s', color='green', markersize=50, label="Ad ZIPs (Targeted)", zorder=4, alpha=0.7)

    # 3) Coverage polygons for School Demand locations
    if not gdf_schools_3857.empty:
        if 'buffer_5_3857' in gdf_schools_3857.columns and gdf_schools_3857['buffer_5_3857'].notna().any():
            gdf_schools_3857[gdf_schools_3857['buffer_5_3857'].notna()].plot(column='buffer_5_3857', ax=ax, edgecolor='#FF4500', facecolor='#FF4500', alpha=0.15, linewidth=1.0, zorder=2) # Orangish Red
        if 'buffer_10_3857' in gdf_schools_3857.columns and gdf_schools_3857['buffer_10_3857'].notna().any():
            gdf_schools_3857[gdf_schools_3857['buffer_10_3857'].notna()].plot(column='buffer_10_3857', ax=ax, edgecolor='#FF8C00', facecolor='#FF8C00', alpha=0.1, linewidth=1.0, zorder=1) # Dark Orange

    # 4) Pie charts for School Demand locations
    if teacher_cols and not gdf_schools_3857.empty:
        for _, row in gdf_schools_3857.iterrows():
            geom = row.geometry
            if geom is None or geom.is_empty: continue
            counts_dict = {tc: row.get(tc, 0) for tc in teacher_cols if pd.notna(row.get(tc,0)) and row.get(tc,0) != 0}
            if counts_dict:
                plot_pie_chart(ax, geom.x, geom.y, counts_dict, get_pie_radius(sum(counts_dict.values())))
    elif not gdf_schools_3857.empty: # Plot demand locations as points if no role data
         gdf_schools_3857.plot(ax=ax, marker='P', color='darkviolet', markersize=80, label="School Demand Locations (No Role Data)", zorder=6, alpha=0.8, edgecolor='black')

    # 5) K-12 School Locations (Optional)
    if not gdf_k12_3857.empty:
        gdf_k12_3857.plot(ax=ax, marker='^', color='dodgerblue', markersize=40, label="K-12 Schools (Uploaded)", zorder=3, alpha=0.7, edgecolor='black')
        # Consider adding school names as text if not too cluttered - for future enhancement

    try:
        ctx.add_basemap(ax, crs=gdf_filtered_3857.crs.to_string() if not gdf_filtered_3857.empty else "EPSG:3857",
                        source=ctx.providers.OpenStreetMap.Mapnik, zoom='auto', attribution_size=5)
    except Exception as e: st.warning(f"Could not add basemap: {e}")

    ax.set_xlim(minx - pad_x, maxx + pad_x)
    ax.set_ylim(miny - pad_y, maxy + pad_y)
    ax.axis('off')

    # --- Legend ---
    handles, labels = [], []
    if not gdf_filtered_3857.empty : handles.append(mpatches.Patch(color='lightgray', label='Contextual ZIPs')); labels.append('Contextual ZIPs')
    if uncovered_zips_geoms: handles.append(mlines.Line2D([], [], color='gold', marker='o', linestyle='None', markersize=8, markeredgecolor='black')); labels.append('Recommended ZIPs (Uncovered by 10mi of Demand)')
    if not gdf_ads_3857.empty: handles.append(mlines.Line2D([], [], color='green', marker='s', linestyle='None', markersize=8)); labels.append('Ad ZIPs (Targeted)')
    if not gdf_schools_3857.empty and 'buffer_5_3857' in gdf_schools_3857: handles.append(mpatches.Patch(facecolor='#FF4500', alpha=0.3, label='5mi Demand Coverage')); labels.append('5-mile Demand Coverage')
    if not gdf_schools_3857.empty and 'buffer_10_3857' in gdf_schools_3857: handles.append(mpatches.Patch(facecolor='#FF8C00', alpha=0.3, label='10mi Demand Coverage')); labels.append('10-mile Demand Coverage')
    if not gdf_k12_3857.empty: handles.append(mlines.Line2D([], [], color='dodgerblue', marker='^', linestyle='None', markersize=8, markeredgecolor='black')); labels.append('K-12 Schools (Uploaded)')

    if teacher_cols and not gdf_schools_geo.empty:
        # Only add pie chart role legend if pies were actually plotted
        if any(sum(row.get(tc, 0) for tc in teacher_cols if pd.notna(row.get(tc,0))) > 0 for _, row in gdf_schools_geo.iterrows()):
            sorted_cols = sorted(teacher_cols)
            color_map_pie = plt.cm.get_cmap('tab20', len(sorted_cols)).colors
            for i, tc in enumerate(sorted_cols):
                handles.append(mpatches.Patch(color=color_map_pie[i % len(color_map_pie)], label=f"Role: {tc}"))
                labels.append(f"Role: {tc}")
    elif not gdf_schools_3857.empty and not teacher_cols : # Legend for demand locations if no role data for pies
        handles.append(mlines.Line2D([], [], color='darkviolet', marker='P', linestyle='None', markersize=10, markeredgecolor='black'))
        labels.append('School Demand Locations')


    if handles: ax.legend(handles, labels, loc='upper left', bbox_to_anchor=(1.02, 1), borderaxespad=0., fontsize='small')
    if teacher_cols and min_jobs != float('inf'):
         ax.text(1.02, 0.4, f"School Demand Range:\nMin Roles: {min_jobs}\nMax Roles: {max_jobs}",
                transform=ax.transAxes, va='center', fontsize='small',
                bbox=dict(boxstyle="round,pad=0.3", fc="wheat", alpha=0.5))

    ax.set_title("School Demand, Ad ZIPs, K-12 Schools & Coverage Map", fontsize=16)
    plt.tight_layout(rect=[0, 0, 0.83, 1])
    return fig

###############################################################################
# STREAMLIT UI AND APP LOGIC
###############################################################################
st.sidebar.header("Upload Data Files (CSV)")
uploaded_us_zips_file = st.sidebar.file_uploader("1. US ZIP Codes (zip, latitude, longitude)", type="csv", key="us_zips")
uploaded_zips_to_sort_file = st.sidebar.file_uploader("2. Ad Target ZIPs (zip)", type="csv", key="zips_to_sort")
uploaded_school_requests_file = st.sidebar.file_uploader("3. School Open Roles (zip, role_counts...)", type="csv", key="school_requests")
uploaded_k12_schools_file = st.sidebar.file_uploader("4. K-12 School Locations (Optional: name, latitude, longitude)", type="csv", key="k12_schools")

if uploaded_us_zips_file and (uploaded_zips_to_sort_file or uploaded_school_requests_file or uploaded_k12_schools_file) :
    st.sidebar.success("Core files uploaded!")

    gdf_us_data = load_us_zip_codes(uploaded_us_zips_file)
    # Load other files only if they are uploaded, otherwise pass empty DataFrames
    df_ads_data = load_zips_to_sort(uploaded_zips_to_sort_file) if uploaded_zips_to_sort_file else pd.DataFrame(columns=['zip'])
    df_schools_data = load_school_requests(uploaded_school_requests_file) if uploaded_school_requests_file else pd.DataFrame()
    gdf_k12_schools_data = load_k12_schools(uploaded_k12_schools_file) if uploaded_k12_schools_file else gpd.GeoDataFrame()


    data_load_success = True
    if gdf_us_data.empty:
        st.error("US ZIP codes data is essential and failed to load. Please check the file.")
        data_load_success = False
    # Warnings for optional files if they fail, but allow proceeding if us_zips is fine
    if uploaded_zips_to_sort_file and df_ads_data.empty:
        st.warning("Problem loading 'Ad Target ZIPs' data. It will be excluded from the map.")
    if uploaded_school_requests_file and df_schools_data.empty:
        st.warning("Problem loading 'School Open Roles' data. It will be excluded from the map.")
    if uploaded_k12_schools_file and gdf_k12_schools_data.empty:
        st.warning("Problem loading 'K-12 School Locations' data. It will be excluded from the map.")


    if data_load_success:
        # Check if there's anything to plot
        can_plot = False
        if not df_ads_data.empty: can_plot = True
        if not df_schools_data.empty: can_plot = True
        if not gdf_k12_schools_data.empty: can_plot = True

        if not can_plot and gdf_us_data.empty: # Redundant check, but good for clarity
             st.error("No data available to plot. Please upload at least Ad Targets, School Roles, or K-12 Schools along with US ZIPs.")
        elif not can_plot and not gdf_us_data.empty:
             st.info("Only US ZIP data loaded. Please upload Ad Targets, School Roles, or K-12 data to see a more detailed map.")
             # Potentially plot just the US zips if a region is selected - future enhancement
        else:
            st.info("Data loaded. Generating map...")
            try:
                map_figure = generate_map_plot(gdf_us_data, df_ads_data, df_schools_data, gdf_k12_schools_data)
                st.pyplot(map_figure)
                st.success("Map generated successfully!")
                fn = 'generated_zip_map_with_recommendations.png'
                img = io.BytesIO()
                map_figure.savefig(img, format='png', dpi=300, bbox_inches='tight')
                st.download_button(label="Download Map as PNG", data=img, file_name=fn, mime="image/png")
            except Exception as e:
                st.error(f"An error occurred during map generation: {e}")
                st.exception(e)
    else:
        st.warning("Map could not be generated due to critical data loading issues (US ZIPs).")
else:
    st.sidebar.info("Please upload 'US ZIP Codes' and at least one of 'Ad Targets', 'School Open Roles', or 'K-12 Schools' to generate the map.")
    st.info("Awaiting file uploads...")

st.markdown("---")
st.markdown("This tool helps visualize geographic relationships for job posting strategies.")